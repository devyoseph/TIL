# 비트 마스킹을 이용한 원소 표현

> 4개의 원소가 비어있다는 것을 표현한다면? 0000
>
> 4개 원소가 모두 채워져 있다면? 1111
>
> 이진수 표현을 이용해 원소의 유무를 빠르게 파악할 수 있다.

​            

## OR 연산( | ) 을 이용한 원소추가

x 번째 원소를 추가하기 위해서는 1을 왼쪽으로 x만큼 Shift 연산한 값과 OR 연산합니다.

```java
101110 : 현재 부분집합의 상태 -> 4번째 원소가 비어있는데 추가하고 싶다면?

010000 : 1<<4 인 값과 OR 연산

111110
```

```java
S |= 1<<x;
```

​                

​            

## AND 연산으로 값 체크

1<<x 를 한 값과 원래 부분집합 S와 AND 연산하고 만약 그 값이 0이 아니라면?

집합에서도 x원소가 있다는 뜻이므로 1을 출력합니다. 만약 0이라면 없는 것이므로 0을 출력합니다.

```java
if(S & 1<<x != 0){
  // 원소 있음
} else{
  // 원소 없음 
}
```

​                  

​                

## AND 연산( & ) 을 이용한 원소제거

x 번째 원소를 제거하기 위해서는 그 부분의 1만 없애주어야합니다.

하나만 제거하기 위해서는 &연산을 이용해야하는데 만약 1<<x 를 하게 되면 1000000의 모습입니다.

and 연산한다면 뒤 0에 의해 값들이 모두 변경되기 때문에 **비트를 뒤집어줍니다**.

01111111 이런 모습으로 만든다음 AND 연산한다면?

0부분이 있는 쪽만 0으로 바뀌고 나머지는 1로 무사할 것입니다.

```java
S &= ~(1<<x);
```

​                 

​               

## XOR 연산( ^ ) 을 이용한 원소 토글(toggle)

XOR의 성질을 이해해야합니다.

원래 원소가 1일 때 0으로 바꾸기 위해서는? 1과 XOR 연산하면 됩니다.

원래 원소가 0일 때 1로 바꾸기 위해서는? 1과 XOR 연산하면 됩니다.

즉 **원래 원소가 1이든 0이든 1과 XOR 연산하면 그 반대가 나옵니다.**

그와 반대로 원소가 무엇이든 0과 XOR 연산하면 그대로 나옵니다.

 이 성질을 이용해 1<<x 값과 XOR연산을 수행합니다.

```java
S ^= 1<<x;
```



​                    

​                  

## NOT 연산을 이용한 모든 원소 추가

원소가 하나도 없는 상태는 0으로 표현합니다.

모든 원소가 있도록 하려면 0을 뒤집습니다.

부분집합 S = ~0 = 111111..... = 모든 원소가 존재하는 상태

```java
S = ~0;
```

