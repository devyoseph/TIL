# 문자열 패턴 매칭

> X 문자열 안에 Y 문자열이 있는지 확인하여라

<img src="algo_textPattern.assets/image-20220224162718107.png" alt="image-20220224162718107" style="zoom:67%;" />

​         

## 고지식한 패턴 매칭?

> **Brute Force** : 앞에서부터 하나하나 일일히 비교하기
>
> O(X*Y) : X의 길이 x Y의 길이만큼의 복잡도

​             

​            

## 라빈-카프 알고리즘

> 최악의 경우(해시값이 계속 같아서 본문 비교를 계속하는 경우) : O(M*N)
>
> 평균적으로는 선형에 가까운 빠른 속도

* 문자열 검색을 위해 해시 값 함수를 이용
* 패턴 내 문자들을 일일히 비교하는 대신 패턴의 해시값과 본문 안에 있는 하위 문자열의 해시 값만을 비교

​        

### 예시

```java
6 8 4 3 2 1 2 4 3 1  // 주어진 문자열

4 3 2 1 // 찾으려는 문자열
```

* 찾으려는 문자열 4 3 2 1 을 숫자로 만든다 = 4*10^3 + 3 *10^2 + 2\*10 + 1
* 원문에서 길이만큼 자른 6 8 4 3을 해시로 구한다 = 6\*10^3 + 8*10^2 + 4\*10 + 3
* 비교한 다음 앞의 6을 버리고 8*10^2 + 4\*10 + 3에 10을 곱한다음 뒤의 수 2를 더한다.
  * 8*10^3 + 4\*10^2 + 3\*10 + 2 = 8432
* **패턴이 문자열이고 길이가 매우 길어지면 MOD 연산을 활용한다**
  * **해쉬값 일치의 오류**: MOD연산을 하는 경우 나눈 나머지가 같다고 해서 둘이 같은 수가 아니므로 본 내용끼리 한 번 더 비교해야한다.

​            

​           

## 보이어 무어 알고리즘

> 최악의 경우 O(M*N)의 복잡도지만
>
> 최선의 시간 복잡도는 O(N/M) = O(Text/Pattern)
>
> `ababs` 같이 반복적인 문자가 많을수록 불리하다 

<img src="algo_textPattern.assets/image-20220224152951679.png" alt="image-20220224152951679" style="zoom:67%;" />

* 오른쪽에서 왼쪽을 비교
* 패턴 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴에 존재하지 않는다면 이동 거리는 패턴 길이만큼 된다.
* 위 그림에서 만약 패턴이 ti**b**ger 처럼 문자내에 b가 있다면 빨간색으로 표시된 b와 겹쳐서 다시 진행한다.

​        

#### skip 배열

* 순간 순간 계산해서 뒤로 이동하는 것이 아니라 skip배열을 참고해서 뒤로 몇 칸 이동할지 결정
* 끝 점과 패턴 맨 뒤의 문자를 비교하고 일치하지 않고  **패턴 내부를 확인할 때 해당 문자와 일치하는 경우** 
  * 아래 배열의 칸만큼 이동할 때 사용

| t    | i    | g    | e    | r    | 다른 모든 문자 |
| ---- | ---- | ---- | ---- | ---- | -------------- |
| 4    | 3    | 2    | 1    | 5    | 5              |

* 맨 뒤 글자가 서로 다른데 t이고 tiger에 t는 포함되므로 글자를 4칸 민다.

​          

​          

## KMP 알고리즘(Knuth-Morris-Pratt Algorithm)

> 시간복잡도 O(M-N)
>
> 중복되는 문자가 많을 때 유리
>
> **패턴 내부에 서로 부분 일치하는 곳을 파악할 수 있는 배열 생성**

* 불일치가 발생한 텍스트 문자열의 앞 부분에 어떤 문자가 있는지 미리 알고 있으므로 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행

````java
ab c ab t // 비교하는 문자열
ab x ab z // 패턴
````

* 위의 경우 `ab`가 중복사용되는데 다시 검사하지않고 미리 만들어둔 배열을 이용해 바로 이동

```java
ab c ab t
	 	 ab x ab z //검사하지 않고 바로 뒤 x부터 검사 시작
```

​        

#### KMP 테이블 배열

* 맨 앞부터 해당 인덱스까지의 길이가 2이상인 부분문자열 중 접두사이면서 접미사인 최대 문자열 구하기
  * 매칭이 실패했을 때 패턴 포인터가 돌아갈 곳을 계산
  * 패턴 0번째 인덱스를 제외한 인덱스마다 맨 앞부터 해당 인덱스까지 **부분 문자열** 중 접두사와 접미사가 일치하는 최대 길이 계산

<img src="algo_textPattern.assets/image-20220224155423599.png" alt="image-20220224155423599" style="zoom:80%;" />

| i    | i 위치까지 부분 문자열 | 접두사이면서 접미사인 최대 문자열 | 길이 |
| ---- | ---------------------- | --------------------------------- | ---- |
| 0    | a                      | X                                 | 0    |
| 1    | ab                     | X                                 | 0    |
| 2    | **a**b**a**            | a                                 | 1    |
| 3    | **abab**               | ab                                | 2    |
| 4    | **ababa**              | aba                               | 3    |
| 5    | ababac                 | X                                 | 0    |
| 6    | **a**babac**a**        | a                                 | 1    |

